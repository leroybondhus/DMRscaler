---
title: "Scratch_User_Guide"
output: html_document
---


Vignettes are long form documentation commonly included in packages. Because they are part of the distribution of the package, they need to be as compact as possible. The `html_vignette` output type provides a custom style sheet (and tweaks some options) to ensure that the resulting html is as small as possible. The `html_vignette` format:

- Never uses retina figures
- Has a smaller default figure size
- Uses a custom CSS stylesheet instead of the default Twitter Bootstrap style

## Vignette Info

Note the various macros within the `vignette` section of the metadata block above. These are required in order to instruct R how to build the vignette. Note that you should change the `title` field and the `\VignetteIndexEntry` to match the title of your vignette.

## Styles

The `html_vignette` template includes a basic CSS theme. To override this theme you can specify your own CSS in the document metadata as follows:

    output: 
      rmarkdown::html_vignette:
        css: mystyles.css

## Figures

The figure sizes have been customised so that you can easily put two images side-by-side. 

```{r, fig.show='hold'}
plot(1:10)
plot(10:1)
```

You can enable figure captions by `fig_caption: yes` in YAML:

    output:
      rmarkdown::html_vignette:
        fig_caption: yes

Then you can use the chunk option `fig.cap = "Your figure caption."` in **knitr**.

## More Examples

You can write math expressions, e.g. $Y = X\beta + \epsilon$, footnotes^[A footnote here.], and tables, e.g. using `knitr::kable()`.

```{r, echo=FALSE, results='asis'}
knitr::kable(head(mtcars, 10))
```

Also a quote using `>`:

> "He who gives up [code] safety for [code] speed deserves neither."
([via](https://twitter.com/hadleywickham/status/504368538874703872))




## Vignette set up

## Download data from GSE74432 

```{r}
library(GEOquery)

## get sample phenotype data table 
gse <- getGEO("GSE149960", GSEMatrix = TRUE)
phen <- gse$GSE149960_series_matrix.txt.gz@phenoData@data
rm(gse)

## get methylation data as idat files (NOTE: this saves files locally in working directory, unpacked size is 411 Mb)
## unpacked size is 411 Mb  
getGEOSuppFiles("GSE149960")
untar("GSE149960/GSE149960_RAW.tar", exdir = "GSE149960/idat")
file.remove("GSE149960/GSE149960_RAW.tar")

idat_files <- list.files("GSE149960/idat", pattern = "idat.gz$", full = TRUE)
sapply(idat_files, gunzip, overwrite = TRUE); rm(idat_files)
```

```{r}
library(minfi)
###  Reading of idat files done with minfi library ###
idats_dir<-"GSE149960/idat"
RGSet <- read.metharray.exp(base = idats_dir)
GRset.funnorm <- preprocessFunnorm(RGSet);rm(RGSet)
snps <- getSnpInfo(object = GRset.funnorm)
GRset.funnorm <- dropLociWithSnps(GRset.funnorm, snps=c("SBE", "CpG"), maf=0);rm(snps)
rm(idats_dir)
```


## Set up for dmrscaler
```{r}

controls <- grep("control",phen$title)
cases <- grep("hgps", phen$title)

locs <- getLocations(GRset.funnorm)
locs <- data.frame("names"=locs@ranges@NAMES, "pos"=locs@ranges@start, "chr" = rep(locs@seqnames@values, locs@seqnames@lengths))
B <- getBeta(GRset.funnorm)

```

###NOTE TO SELF CLEAN UP dmrscaler documentation
```{r}
library("devtools")
library(roxygen2)
document()
install("../dmrscaler")
```


```{r set up dmrscaler function }

library(doParallel)
library(rlang)
library("dplyr")
library(foreach)
registerDoParallel(detectCores())


      ############################     run everything         #########################
      num_perm <- 10
      clt_reps <- 1e4
      
      rim <- dmrscaler::generate_rand_index_matrix(num_controls = length(controls),
                                                   num_cases = length(cases),
                                                   num_permutations = num_perm)
      mrp <- dmrscaler::run_MWW_rand_permutation(index_matrix = rim, 
                                                 Beta = B,
                                                 num_permutations = num_perm)
      mrp <- -log10(mrp)
      mwr <- dmrscaler::run_MWW(control_indices = controls ,
                                case_indices = cases ,
                                Beta = B)
      mwr <- -log10(mwr)
      fdt <- dmrscaler::write_FDR_table(real_table = mwr,
                                        rand_table = mrp)
      
      fdrscaler <- dmrscaler::get_FDR_scalar(MWW_FDR_table = fdt,
                                             MWW_FDR_threshold = 0.1)
      if(is.na(fdrscaler)){fdrscaler <- 1}
      ## needs
      cltable <- dmrscaler::write_CLT_lookup_table(num_reps = clt_reps ,
                                                   data_to_sample = mwr$p_val,
                                                   FDR_scaler = fdrscaler,
                                                   clt_numCGs = c(2, 5, 10, 25, 50))
      ## data <-  names, chr, pos,  scoring_value (-log10pval)
    #  data <- controlCGlocs
      data <- locs[,1:3]
      data$chr <- as.factor(data$chr)
      colnames(data)<-c("names","pos","chr")
      data$scoring_values <- mwr$p_val
    #  data$chr <- droplevels(data$chr)
      layer_sizes <- c(4,8,16,32,64)
      layers<-list()
      for(i in 1:length(layer_sizes)){
        print(paste("layer", i, sep="_"))
        nn_step_fraction = 2 
        nn_step_size <- floor(layer_sizes[i] / nn_step_fraction)
        nn <- dmrscaler::n_nearest_window_scoring_func(indat = data, n_nearest = layer_sizes[i], step_size = nn_step_size, FDR = fdrscaler)
        signn <- dmrscaler::determine_significant_windows(window_results=nn, indat=data, quants=cltable , quants_significance_cutoff = "0.9999" )
        signn <- dmrscaler::add_significance(three_window_list =  signn, lookup_table = cltable)
        
        ## multiple chromosomes each a list, coerce to single dataframe
        signn <- bind_rows(signn)
        ## 
        
        layers[[i]]<-signn
      }
      
      layers_TEMP_BACKUP <- layers
      layers<-layers_TEMP_BACKUP
      
      names(layers)<-paste("layer", layer_sizes, sep="_")
      
      
      atomic_layer <- data
      for(i in 1:length(layers)){
        for(k in 1:length(layers[[i]]$start_pos)){
          layers[[i]]$start_index[k]<-which(atomic_layer$pos==layers[[i]]$start_pos[k] & as.character(atomic_layer$chr) == as.character(layers[[i]]$chr[k]))
          layers[[i]]$stop_index[k]<-which(atomic_layer$pos==layers[[i]]$stop_pos[k] & as.character(atomic_layer$chr) == as.character(layers[[i]]$chr[k]))
        }
      }
      built_layers <- list()
      built_layers[[1]] <- in_layer_merge(dmrs = layers[[1]], CG_table = atomic_layer, FDR_scaler = fdrscaler, lookup_table = cltable)
      built_layers[[1]] <- in_layer_merge(dmrs = built_layers[[1]], CG_table = atomic_layer, FDR_scaler = fdrscaler, lookup_table = cltable)
      built_layers[[1]] <- trim_layer(dmrs = built_layers[[1]], CG_table = atomic_layer, FDR_scaler = 2, lookup_table = cltable)
      for(i in 2:length(layers)){
        #print(i)
        built_layers[[i]] <- build_next_layer(prev_layer = built_layers[[i-1]], 
                                              windows_to_layer = layers[[i]], 
                                              CG_table = atomic_layer,
                                              FDR_scaler=fdrscaler,
                                              lookup_table = cltable)
      built_layers[[i]] <- in_layer_merge(dmrs = built_layers[[i]], CG_table = atomic_layer, FDR_scaler = fdrscaler, lookup_table = cltable)
      built_layers[[i]] <- in_layer_merge(dmrs = built_layers[[i]], CG_table = atomic_layer, FDR_scaler = fdrscaler, lookup_table = cltable)
      built_layers[[i]] <- trim_layer(dmrs = built_layers[[i]], CG_table = atomic_layer, FDR_scaler = 2, lookup_table = cltable)
       # print("done with one")
      }

```

