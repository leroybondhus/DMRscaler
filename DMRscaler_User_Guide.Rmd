---
title: "The DMRscaler user's guide"
author: "Leroy Bondhus"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{The DMRscaler user's guide}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```


## Summary
dmrscaler


### install dmrscaler (BIOCONDUCTOR SUBMISSION IN PROGRESS)
###NOTE TO SELF CLEAN UP dmrscaler documentation
```{r}
library("devtools")
library(roxygen2)
document()
install("../dmrscaler")
```

## Example Dataset Setup
We will use data from GSE149960 from (REFERENCE) with DNA methylation from fibroblasts from progeria patients and controls measured on the Illumina methylation EPIC array.  
## Download data from GSE74432 

```{r}
library(GEOquery)

## get sample phenotype data table 
gse <- getGEO("GSE149960", GSEMatrix = TRUE)
phen <- gse$GSE149960_series_matrix.txt.gz@phenoData@data
rm(gse)

## get methylation data as idat files (NOTE: this saves files locally in working directory, unpacked size is 411 Mb)
## unpacked size is 411 Mb  
getGEOSuppFiles("GSE149960")
untar("GSE149960/GSE149960_RAW.tar", exdir = "GSE149960/idat")
file.remove("GSE149960/GSE149960_RAW.tar")

idat_files <- list.files("GSE149960/idat", pattern = "idat.gz$", full = TRUE)
sapply(idat_files, gunzip, overwrite = TRUE); rm(idat_files)
```



###  Preprocessing idat files with minfi 
```{r preprocessing_data}
library(minfi)
###  Reading of idat files done with minfi library ###
idats_dir<-"GSE149960/idat"
RGSet <- read.metharray.exp(base = idats_dir)
GRset.funnorm <- preprocessFunnorm(RGSet);rm(RGSet)
snps <- getSnpInfo(object = GRset.funnorm)
GRset.funnorm <- dropLociWithSnps(GRset.funnorm, snps=c("SBE", "CpG"), maf=0);rm(snps)
rm(idats_dir)
```


## Set up for dmrscaler
```{r}

controls <- grep("control",phen$title)
cases <- grep("hgps", phen$title)

locs <- getLocations(GRset.funnorm)
locs <- data.frame("names"=locs@ranges@NAMES, "pos"=locs@ranges@start, "chr" = rep(locs@seqnames@values, locs@seqnames@lengths))
B <- getBeta(GRset.funnorm)

```



```{r set up dmrscaler function }

library(doParallel)
library(rlang)
library("dplyr")
library(foreach)
registerDoParallel(detectCores())


############################     run everything         #########################
num_perm <- 10
clt_reps <- 1e4

rim <- dmrscaler::generate_rand_index_matrix(num_controls = length(controls),
                                             num_cases = length(cases),
                                             num_permutations = num_perm)
mrp <- dmrscaler::run_MWW_rand_permutation(index_matrix = rim, 
                                           Beta = B,
                                           num_permutations = num_perm)
mrp <- -log10(mrp)
mwr <- dmrscaler::run_MWW(control_indices = controls ,
                          case_indices = cases ,
                          Beta = B)
mwr <- -log10(mwr)
fdt <- dmrscaler::write_FDR_table(real_table = mwr,
                                  rand_table = mrp)

fdrscaler <- dmrscaler::get_FDR_scalar(MWW_FDR_table = fdt,
                                       MWW_FDR_threshold = 0.1)
if(is.na(fdrscaler)){fdrscaler <- 1}
## needs
cltable <- dmrscaler::write_CLT_lookup_table(num_reps = clt_reps ,
                                             data_to_sample = mwr$p_val,
                                             FDR_scaler = fdrscaler,
                                             clt_numCGs = c(2, 5, 10, 25, 50))
locs$chr <- as.factor(locs$chr)
locs$scoring_values <- mwr$p_val
```

```{r}
result <- dmrscaler::dmrscaler(locs = locs, fdrscaler = fdrscaler, cltable=cltable, layer_sizes = c(4,8,16,32,64))

```


```{r}
example_region <- data.frame(chr="chr7", start=157280000, stop=158364000, stringsAsFactors = FALSE)

library(circlize)
library(HilbertCurve)

col_fun = colorRamp2(c(0,fdrscaler*0.99,fdrscaler,max(locs$scoring_values)), c("grey30", "grey60", "red", "red"))
level = 6
## 4^level - 1 = # segments

hc_points <- locs[which(locs$chr== example_region$chr ),]
hc_max <- nrow(hc_points)
hc_col <- col_fun(hc_points$scoring_values)
hc_size <- hc_points$scoring_values / max(hc_points$scoring_values)

#  hc_size <- hc_points$scoring_values / fdrscaler
hc <- HilbertCurve(s=1,e=hc_max, level = level, reference = F, title = paste("chr",i,sep = ""))
hc_points(hc, x1 = 1:nrow(hc_points), np = NULL, pch=15, size = unit(hc_size*2, "mm"),gp = gpar(col = hc_col, fill = hc_col))
hc_polygon(hc, x1 = min(which(hc_points$pos >= example_region$start)), x2 = max(which(hc_points$pos <= example_region$stop)) )

### now looking only at the specified region
level = 4
hc_points <- locs[which(locs$chr== example_region$chr & locs$pos >= example_region$start & locs$pos <= example_region$stop ),]
hc_max <- nrow(hc_points)
hc_col <- col_fun(hc_points$scoring_values)
hc_size <- hc_points$scoring_values / max(hc_points$scoring_values)

#  hc_size <- hc_points$scoring_values / fdrscaler
hc <- HilbertCurve(s=1,e=hc_max, level = level, reference = F, title = paste("chr",i,sep = ""))
hc_points(hc, x1 = 1:nrow(hc_points), np = NULL, pch=15, size = unit(hc_size*4, "mm"),gp = gpar(col = hc_col, fill = hc_col))



```

## Explore some features of the data
dmrscaler defines differential methylation features iteratively, expanding the size of the window for aggregating on at each step
this procedure allows a hierarchical structure to describe a region enriched in differntially methylated CpGs. We look at our example region here 
```{r}
library(networkD3)

dmr_tree <- generate_dmr_tree(dmrscaler_result = result, layer=5, chr=example_region$chr, start = example_region$start, stop = example_region$stop)
diagonalNetwork(List = dmr_tree, fontSize = 12, fontFamily = "bold", nodeStroke = "black", linkColour = "black", opacity = 1)

```



Vignettes are long form documentation commonly included in packages. Because they are part of the distribution of the package, they need to be as compact as possible. The `html_vignette` output type provides a custom style sheet (and tweaks some options) to ensure that the resulting html is as small as possible. The `html_vignette` format:

- Never uses retina figures
- Has a smaller default figure size
- Uses a custom CSS stylesheet instead of the default Twitter Bootstrap style

## Vignette Info

Note the various macros within the `vignette` section of the metadata block above. These are required in order to instruct R how to build the vignette. Note that you should change the `title` field and the `\VignetteIndexEntry` to match the title of your vignette.

## Styles

The `html_vignette` template includes a basic CSS theme. To override this theme you can specify your own CSS in the document metadata as follows:

    output: 
      rmarkdown::html_vignette:
        css: mystyles.css

## Figures

The figure sizes have been customised so that you can easily put two images side-by-side. 

```{r, fig.show='hold'}
plot(1:10)
plot(10:1)
```

You can enable figure captions by `fig_caption: yes` in YAML:

    output:
      rmarkdown::html_vignette:
        fig_caption: yes

Then you can use the chunk option `fig.cap = "Your figure caption."` in **knitr**.

## More Examples

You can write math expressions, e.g. $Y = X\beta + \epsilon$, footnotes^[A footnote here.], and tables, e.g. using `knitr::kable()`.

```{r, echo=FALSE, results='asis'}
knitr::kable(head(mtcars, 10))
```

Also a quote using `>`:

> "He who gives up [code] safety for [code] speed deserves neither."
([via](https://twitter.com/hadleywickham/status/504368538874703872))
